---
marp: true
theme: default
class: invert
paginate: true
header: "スペック駆動開発ガイド"
footer: "Key Management Service"
---

# スペック駆動開発ガイド

**Claude Code を活用した開発プロセス**

---

# アジェンダ

1. スペック駆動開発とは
2. 基本フロー（7ステップ）
3. ディレクトリ構造
4. 主要コマンド
5. 日常的な使い方

---

# スペック駆動開発とは

**ドキュメントを中心に開発を進めるアプローチ**

- 設計書（スペック）を先に作成
- 実装は設計書に基づいて実行
- 設計と実装の整合性を常に維持

---

# 今回実施した開発プロセス

```
1. ドキュメント作成    → docs/ で「何を作るか」を定義
2. 作業計画           → .steering/ で「今回何をするか」を計画
3. 作業計画と設計書の比較 → 整合性を確保
4. 実装              → tasklist.md に従って実装
5. 実装の検証         → テストと動作確認
6. 実装と設計書の比較   → 差異を抽出し整合性を確保
7. 設計書の更新       → 必要に応じてドキュメント更新
```

---

# ディレクトリ構造

## 2種類のドキュメント

| 種類 | 場所 | 役割 |
|------|------|------|
| 永続的ドキュメント | `docs/` | プロジェクト全体の「北極星」 |
| 作業単位ドキュメント | `.steering/` | 今回の作業に特化 |

---

# 永続的ドキュメント (`docs/`)

**プロジェクト全体の「何を作るか」「どう作るか」を定義**

| ファイル | 内容 |
|----------|------|
| `product-requirements.md` | プロダクト要求定義書 |
| `functional-design.md` | 機能設計書 |
| `architecture.md` | 技術仕様書 |
| `repository-structure.md` | リポジトリ構造定義書 |
| `development-guidelines.md` | 開発ガイドライン |

---

# 作業単位ドキュメント (`.steering/`)

**特定の開発作業における「今回何をするか」を定義**

```
.steering/20250115-add-user-profile/
├── requirements.md   # 今回の要求内容
├── design.md         # 実装アプローチ
└── tasklist.md       # 具体的なタスクリスト
```

命名規則: `YYYYMMDD-タスク名`

---

# 主要コマンド一覧

## 設計ドキュメント作成

| コマンド | 用途 |
|----------|------|
| `/create-prd` | プロダクト要求定義書を作成 |
| `/create-functional-design` | 機能設計書を作成 |
| `/create-architecture` | アーキテクチャ設計書を作成 |
| `/create-repo-structure` | リポジトリ構造定義書を作成 |
| `/create-dev-guidelines` | 開発ガイドラインを作成 |

---

# 主要コマンド一覧

## 機能追加

| コマンド | 用途 |
|----------|------|
| `/plan-feature [機能]` | 設計書・タスクリストを作成 |
| `/create-feature [パス]` | 機能を実装 |

## 整合性チェック

| コマンド | 用途 |
|----------|------|
| `/compare-steering-design` | ステアリング ⇔ 設計書の差異を抽出 |
| `/compare-implementation-design` | ソースコード ⇔ 設計書の差異を抽出 |

---

# 重要なルール

## ドキュメント作成時

**1ファイルずつ作成し、必ずユーザーの承認を得てから次に進む**

```
「[ドキュメント名]の作成が完了しました。
内容を確認してください。
承認いただけたら次のドキュメントに進みます。」
```

---

# 重要なルール

## 実装前の確認

新しい実装を始める前に、必ず以下を確認:

1. **CLAUDE.md を読む**
2. **関連する永続ドキュメント（`docs/`）を読む**
3. **Grep で既存の類似実装を検索**
4. **既存パターンを理解してから実装開始**

---
# ドキュメント管理の原則

| 種類 | 特徴 |
|------|------|
| **永続的ドキュメント** | 基本設計を記述 / 頻繁に更新されない / プロジェクト全体の「北極星」 |
| **作業単位ドキュメント** | 特定の作業に特化 / 作業ごとに新規作成 / 履歴として保持 |

---

# ワークフロー図

```
┌─────────────────────────────────────────────────────────────┐
│                    永続的ドキュメント (docs/)                │
│  PRD → 機能設計 → アーキテクチャ → リポジトリ構造 → ガイドライン │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│              作業単位ドキュメント (.steering/)               │
│         requirements.md → design.md → tasklist.md          │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                         実装                                │
│              tasklist.md に従ってコーディング                 │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                       整合性チェック                         │
│    /compare-steering-design  /compare-implementation-design │
└─────────────────────────────────────────────────────────────┘
```

---

# まとめ

1. **設計書ファースト**: ドキュメントを先に作成
2. **2層構造**: 永続的ドキュメント + 作業単位ドキュメント
3. **整合性維持**: 設計と実装の差異を定期的にチェック
4. **コマンド活用**: 定型作業はスラッシュコマンドで効率化
5. **会話ベース**: 日常的な依頼は普通に会話でOK

---
# やってみて

- 開発環境の整備（ランタイムバージョンのインストール、linterのインストール等）は精度が出なかった。
    - 実装に必要な環境はあらかじめ人手で整備しておいた方が良さそう
- 設計書に記載があっても実装されないケースがあった
    - steeringの計画フェーズで潰すか、人間のレビュ＆テストで潰すしかない
- LLMにやらせるより人手で修正した方が早いケースもあるが、実装と設計に乖離が起きてモヤモヤする
    - 設計と実装の差異分析&フィードバックをさせる仕組みを用意して対策した

---
# やってみて
- 生成されたコードで上手く動作しないときのデバッグがしんどかった
    - コーディング規約として、最初からエラーハンドリングやログ出力ルールを徹底させた方がいい

- 上記に関連して、ローカルで容易に確実にデバッグできる環境を用意しておくことも重要だった
    - 人間が迅速にトラブルシューティング＆修正をしやすい状態を整えておくと良い
    - クラウドにデプロイしないと動作確認できないと認知負荷もあいまって、解析と修正に時間がかかりすぎる

---
# スペック駆動開発なら誰でも求められる品質を満たした開発ができるか？
- 今回の結果から言うと、改めて**厳しい**と感じた
    - 設計時点で実装レベルまで落とし込むため、自分で実装できる人間じゃないと妥当性の判断が難しい
    - 実装漏れや誤りを指摘、修正できる必要がある
    - 自分が書いたコードよりもデバッグに時間がかかる
---
# メリットはありそうか
- あるとは思う。
- 実装できる人間が使えば、設計と実装のタスクを分離して並列化できるので開発速度は上がると思う。
    - A機能を実装させながら、B機能の設計や実装が可能
- 今回のケースでは、レビュ負荷の増加以上に実装速度が向上して結果的に早く実装できたと思う。
- 設計書が最新に保たれる（頭の中ではなくファイルに残る）のも良いと思った。
    
---
# その他学びや気づき
- 今回のような複雑ではない機能開発において、設計書に書かれていても実装漏れや誤りが発生したことから、規模が大きくなったり実装難易度が高いと精度がでず、レビュやデバッグの負担の方が大きくなる可能性が高いことから、適用する機能や規模感を見極めることが重要かもしれない。
- ↑既存機能の改修であればそんなに気にしなくても大丈夫なのかもしれない。

---

# 参考資料

- `CLAUDE.md` - プロジェクトメモリ（本資料の元ファイル）
- `docs/` - 永続的ドキュメント一式
- `.claude/commands/` - 利用可能なコマンド定義
